## Изменения окружения

### Добавлен файл .gitignore 
Для исключения попадания нежелательных файлов и папок в репозиторий, например папки .idea или vendor 

### Добавлен файл Makefile
Для удобства запуска повторяемых команд, такие как поднятие проекта или прогон проверок и тестов 

### Обновление версии php до 8.1
- Обновление php до версии 8.1
- Сброс версий yii в "*". Это упрощение для простоты перехода на 8.1. В реальном проекте нужно явно прописывать версии фреймворка

Позволяет использовать все доступные возможности php для контроля кода на уровне типов, включая перечисления. Это упрощает контроль за типами и сложность поддержки проекта.

### Установка phpstan
Позволяет статически проверять код чтобы выявить возможные опечатки и нестыковки на урове кода

### Установка easy-coding-standard
Позволяет системно настраивать и поддерживать кодестайл в проекте.

## Изменения кода 

### Написание юнит тестов для проверки работоспособности кода

Один из самых важных элементов рефакторинга. Позволяет точно знать что код выполняет поставленную задачу при последующих рефакторингах и изменеии кода.
Без покрытия тестами существенно повышается риск возникновения регрессионных ошибок.

Общий тест который покрывал сначала хелпер форматтер, а сейчас подтверждает работоспособность текущего кода - tests/components/HistoryBodyFormatter/HistoryBodyFormatterTest.php

### Зайдействован Dependency Injection Container

- Определены зависимости в классе bootstrap/ServicesDefinitions.php
- Форматирование тела сообщение реализовано через сервис components/HistoryBodyFormatter/HistoryBodyFormatter.php

Позволяет легко использовать принцип внедрения зависимостей, что по сути разделяет фазы сборки классов-сервисов и дальнейшее их использование. 
Использование координально изменяет архитектуру кода, и улучшает тестируемость, поддерживаемость и прозрачность кода. 

### Разделение задачи форматирования по типу эвентов

- Добавлен общий сервис форматирования ответов: components/HistoryBodyFormatter/HistoryBodyFormatter.php
- Добавлен интерфейс components/HistoryBodyFormatter/EventFormatter/EventFormatterInterface.php определящий способ для определения поддерживаемых типов событий
- Добавлен интерфейс components/HistoryBodyFormatter/HistoryFormatterInterface.php для интерфейса форматирования
- Добавлены классы форматтеров для всех необходимых групп событий - components/HistoryBodyFormatter/EventFormatter/**

При Использовании единого SWITCH блока для обработки всех возможных типов эвентов могут возникнуть следующие проблемы:

- При увеличении количества типов будет также увеличиваться размер метода класса. В последствии это будет тяжело восприниматься человеком и это будет увелечение сложности по поддержке данного метода.
- Нарушение принципа open-closed principle, так что при каждом добавлении нового типа мы будем вынуждены контактировать с кодом обрабатывающем старые типы и это может приводить к регрессионным багам.
- В случае если для форматирования типов требуются зависимости они будут являться избыточными для других типов событий, и будут загромождать код.

В новой реализации для добавления новых эвентов мы только создаем новый класс что минизирует риски образования регрессионных багов 
Также при необходимости изменения логики форматирования мы легко можем найти и исправить логику исключительно для необходимого эвента.

### Разделение логики шаблона _item.php на несколько

Используется такой же принцип как и в случае обработки текста тела событий. Нам необходимо разделить один большой switch в одном файле на несколько файлов и конфигурацией на основе массив.
Для добавления новых типов нужно добавить новый шаблон и указать данный шаблон в конфигурации

### Константы типов эвентов вынесены из History в перечисление HistoryEvent
Позволяет задействовать типы перечислений для структурирования констант и раннего выявляения проблем с возможными типами эвентов на уровне кода.

### Легкий рефакторинг по добавлению типов аргументов, возвращаемых значений и удалению phpDoc
- Увеличивает покрытие кода типами что в свою очередь увеличивает долю ошибок которые можно обнаружить на уровне кода. 
- При явном объявлении типов - большая часть phpDoc становится избыточной


## Проблема с экспортом в случае большого количества данных

### Проблема памяти 
 
Может возникнуть ситуация кода объем данных и сопутствующих расходов на представление этих данных в php превысит доступную оперативную память.
Для решения данной проблемы можно выбирать данные из базы данных порционно, в цикле и записывать их во временных файл, а затем очищать память от полученного набора данных. 
Повторя данную процедуру мы можем сформировать файл любого необходимого объема. 

Далее можно сформировать ответ из данного файла не загружая весь файл в память.

### Проблема времени

- В случае если процесс генерации файла будет занимать большое количество времени, а количество запросов на скачивание будет также большим, начнется нехватка свободных процессов пхп для обработки запросов.
- Также это может вызвать недоумение у пользователей и ощущение что сайт завис. Этап формирования CSV не дает обратной связи.
- В случае если пользователь закроет страницу или прервет запрос, формирование файла остановится и процесс потеряется.

Здесь есть несколько решений и их можно применять по отдельности или вместе в зависимости от обстоятельств.

- Использовать асинхронное формирование файла. При запросе будет формироваться только заявка на создание файла и пользователю возвращаться ответ об успешном формировании заявки. Другой процесс в системе сформирует файл в фоновом режими. И затем третий запрос позволит пользователю скачать уже готовый файл.
- Сохранять файл и использовать его в течении некоторого времени для последующих запросов
- Кешировать запрос на скачивание файла на стороне nginx. 